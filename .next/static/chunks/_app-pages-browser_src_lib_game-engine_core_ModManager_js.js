"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_game-engine_core_ModManager_js"],{

/***/ "(app-pages-browser)/./src/lib/game-engine/core/ModManager.js":
/*!************************************************!*\
  !*** ./src/lib/game-engine/core/ModManager.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModManager: () => (/* binding */ ModManager)\n/* harmony export */ });\n/**\r\n * Mod Manager\r\n * \r\n * Handles loading and management of game mods.\r\n * Supports mod discovery, loading, and dependency resolution.\r\n */ class ModManager {\n    /**\r\n     * Initialize the mod manager\r\n     */ async initialize() {\n        console.log('Initializing Mod Manager');\n        // Discover available mods\n        await this.discoverMods();\n        // Load base game mod by default\n        await this.loadMod('base-game');\n        console.log('Mod Manager initialized');\n    }\n    /**\r\n     * Discover available mods in the mods directory\r\n     */ async discoverMods() {\n        try {\n            // For now, we'll hardcode the base game mod\n            // In the future, this could scan the mods directory\n            const baseGameManifest = await this.loadModManifest('mods/base-game/manifest.json');\n            this.modManifests.set('base-game', baseGameManifest);\n            console.log(\"Discovered \".concat(this.modManifests.size, \" mod(s)\"));\n        } catch (error) {\n            console.error('Error discovering mods:', error);\n        }\n    }\n    /**\r\n     * Load a mod by ID\r\n     * @param {string} modId - The mod ID to load\r\n     * @returns {Object} The loaded mod data\r\n     */ async loadMod(modId) {\n        try {\n            console.log(\"Loading mod: \".concat(modId));\n            const manifest = this.modManifests.get(modId);\n            if (!manifest) {\n                throw new Error(\"Mod manifest not found: \".concat(modId));\n            }\n            // Check dependencies\n            await this.checkDependencies(manifest);\n            // Load mod data\n            const modData = await this.loadModData(manifest);\n            // Load mod assets\n            await this.loadModAssets(manifest);\n            // Load localization\n            await this.loadModLocalization(manifest);\n            // Store loaded mod\n            this.loadedMods.set(modId, {\n                manifest,\n                data: modData,\n                assets: {},\n                localization: {}\n            });\n            this.activeMods.add(modId);\n            this.modLoadOrder.push(modId);\n            // Emit mod loaded event\n            this.eventSystem.emit('mod:loaded', {\n                modId,\n                manifest,\n                data: modData\n            });\n            console.log(\"Mod loaded successfully: \".concat(modId));\n            return modData;\n        } catch (error) {\n            console.error(\"Failed to load mod \".concat(modId, \":\"), error);\n            throw error;\n        }\n    }\n    /**\r\n     * Load mod manifest from file\r\n     * @param {string} manifestPath - Path to the manifest file\r\n     * @returns {Object} The manifest data\r\n     */ async loadModManifest(manifestPath) {\n        try {\n            const response = await fetch(manifestPath);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Failed to load mod manifest \".concat(manifestPath, \":\"), error);\n            throw error;\n        }\n    }\n    /**\r\n     * Check mod dependencies\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async checkDependencies(manifest) {\n        const dependencies = manifest.dependencies || [];\n        for (const dependency of dependencies){\n            if (!this.loadedMods.has(dependency)) {\n                throw new Error(\"Missing dependency: \".concat(dependency));\n            }\n        }\n    }\n    /**\r\n     * Load mod data files\r\n     * @param {Object} manifest - The mod manifest\r\n     * @returns {Object} The loaded data\r\n     */ async loadModData(manifest) {\n        const data = {};\n        const dataFiles = manifest.data || {};\n        for (const [key, path] of Object.entries(dataFiles)){\n            try {\n                if (path.endsWith('/')) {\n                    // Directory - load all JSON files in directory\n                    data[key] = await this.loadDataDirectory(path);\n                } else {\n                    // Single file\n                    const response = await fetch(path);\n                    if (!response.ok) {\n                        console.warn(\"Failed to load data file: \".concat(path));\n                        continue;\n                    }\n                    data[key] = await response.json();\n                }\n            } catch (error) {\n                console.warn(\"Failed to load data file \".concat(path, \":\"), error);\n            }\n        }\n        return data;\n    }\n    /**\r\n     * Load all JSON files in a directory\r\n     * @param {string} directoryPath - Path to the directory\r\n     * @returns {Object} Object with filename keys and data values\r\n     */ async loadDataDirectory(directoryPath) {\n        // For now, we'll return an empty object\n        // In a real implementation, this would scan the directory\n        return {};\n    }\n    /**\r\n     * Load mod assets\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async loadModAssets(manifest) {\n        const assets = manifest.assets || {};\n        // For now, we'll just log the asset paths\n        // In a real implementation, this would preload assets\n        console.log('Mod assets:', assets);\n    }\n    /**\r\n     * Load mod localization\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async loadModLocalization(manifest) {\n        const localization = manifest.localization || {};\n        const defaultLang = localization.default || 'en';\n        const langPath = localization.path || 'localization/';\n        try {\n            const response = await fetch(\"\".concat(langPath).concat(defaultLang, \".json\"));\n            if (response.ok) {\n                const langData = await response.json();\n                console.log('Loaded localization:', langData);\n            }\n        } catch (error) {\n            console.warn('Failed to load localization:', error);\n        }\n    }\n    /**\r\n     * Get loaded mod data\r\n     * @param {string} modId - The mod ID\r\n     * @returns {Object} The mod data\r\n     */ getModData(modId) {\n        const mod = this.loadedMods.get(modId);\n        return mod ? mod.data : null;\n    }\n    /**\r\n     * Get all loaded mod data merged together\r\n     * @returns {Object} Merged data from all loaded mods\r\n     */ getAllModData() {\n        const mergedData = {};\n        for (const [modId, mod] of this.loadedMods){\n            for (const [key, value] of Object.entries(mod.data)){\n                if (!mergedData[key]) {\n                    mergedData[key] = {};\n                }\n                // Merge data (mods loaded later override earlier ones)\n                if (typeof value === 'object' && value !== null) {\n                    Object.assign(mergedData[key], value);\n                } else {\n                    mergedData[key] = value;\n                }\n            }\n        }\n        return mergedData;\n    }\n    /**\r\n     * Get active mods\r\n     * @returns {Set} Set of active mod IDs\r\n     */ getActiveMods() {\n        return this.activeMods;\n    }\n    /**\r\n     * Get mod load order\r\n     * @returns {Array} Array of mod IDs in load order\r\n     */ getModLoadOrder() {\n        return this.modLoadOrder;\n    }\n    /**\r\n     * Unload a mod\r\n     * @param {string} modId - The mod ID to unload\r\n     */ unloadMod(modId) {\n        if (this.loadedMods.has(modId)) {\n            this.loadedMods.delete(modId);\n            this.activeMods.delete(modId);\n            const index = this.modLoadOrder.indexOf(modId);\n            if (index > -1) {\n                this.modLoadOrder.splice(index, 1);\n            }\n            this.eventSystem.emit('mod:unloaded', {\n                modId\n            });\n            console.log(\"Mod unloaded: \".concat(modId));\n        }\n    }\n    /**\r\n     * Reload a mod\r\n     * @param {string} modId - The mod ID to reload\r\n     */ async reloadMod(modId) {\n        this.unloadMod(modId);\n        await this.loadMod(modId);\n    }\n    constructor(eventSystem, assetLoader){\n        this.eventSystem = eventSystem;\n        this.assetLoader = assetLoader;\n        this.loadedMods = new Map();\n        this.modManifests = new Map();\n        this.activeMods = new Set();\n        this.modLoadOrder = [];\n    }\n}\nif (true) window.ModManager = ModManager;\n// ES Module exports\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZS1lbmdpbmUvY29yZS9Nb2RNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVELE1BQU1BO0lBVUY7O0tBRUMsR0FDRCxNQUFNQyxhQUFhO1FBQ2ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDBCQUEwQjtRQUMxQixNQUFNLElBQUksQ0FBQ0MsWUFBWTtRQUV2QixnQ0FBZ0M7UUFDaEMsTUFBTSxJQUFJLENBQUNDLE9BQU8sQ0FBQztRQUVuQkgsUUFBUUMsR0FBRyxDQUFDO0lBQ2hCO0lBRUE7O0tBRUMsR0FDRCxNQUFNQyxlQUFlO1FBQ2pCLElBQUk7WUFDQSw0Q0FBNEM7WUFDNUMsb0RBQW9EO1lBQ3BELE1BQU1FLG1CQUFtQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDO1lBQ3BELElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsYUFBYUg7WUFFbkNKLFFBQVFDLEdBQUcsQ0FBQyxjQUFxQyxPQUF2QixJQUFJLENBQUNLLFlBQVksQ0FBQ0UsSUFBSSxFQUFDO1FBQ3JELEVBQUUsT0FBT0MsT0FBTztZQUNaVCxRQUFRUyxLQUFLLENBQUMsMkJBQTJCQTtRQUM3QztJQUNKO0lBRUE7Ozs7S0FJQyxHQUNELE1BQU1OLFFBQVFPLEtBQUssRUFBRTtRQUNqQixJQUFJO1lBQ0FWLFFBQVFDLEdBQUcsQ0FBQyxnQkFBc0IsT0FBTlM7WUFFNUIsTUFBTUMsV0FBVyxJQUFJLENBQUNMLFlBQVksQ0FBQ00sR0FBRyxDQUFDRjtZQUN2QyxJQUFJLENBQUNDLFVBQVU7Z0JBQ1gsTUFBTSxJQUFJRSxNQUFNLDJCQUFpQyxPQUFOSDtZQUMvQztZQUVBLHFCQUFxQjtZQUNyQixNQUFNLElBQUksQ0FBQ0ksaUJBQWlCLENBQUNIO1lBRTdCLGdCQUFnQjtZQUNoQixNQUFNSSxVQUFVLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUNMO1lBRXZDLGtCQUFrQjtZQUNsQixNQUFNLElBQUks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Q3RCLElBQUksQ0FBQzNDLFlBQVksR0FBRyxFQUFFO0lBQzFCO0FBOFFKO0FBRUEsSUFBSSxJQUE2QixFQUFFNEMsT0FBT3ZFLFVBQVUsR0FBR0E7QUFFdkQsb0JBQW9CO0FBQ0UiLCJzb3VyY2VzIjpbIkM6XFxHaXRIdWJcXFNlbGZcXHRhdmVybnNcXHNyY1xcbGliXFxnYW1lLWVuZ2luZVxcY29yZVxcTW9kTWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTW9kIE1hbmFnZXJcclxuICogXHJcbiAqIEhhbmRsZXMgbG9hZGluZyBhbmQgbWFuYWdlbWVudCBvZiBnYW1lIG1vZHMuXHJcbiAqIFN1cHBvcnRzIG1vZCBkaXNjb3ZlcnksIGxvYWRpbmcsIGFuZCBkZXBlbmRlbmN5IHJlc29sdXRpb24uXHJcbiAqL1xyXG5cclxuY2xhc3MgTW9kTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFN5c3RlbSwgYXNzZXRMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50U3lzdGVtID0gZXZlbnRTeXN0ZW07XHJcbiAgICAgICAgdGhpcy5hc3NldExvYWRlciA9IGFzc2V0TG9hZGVyO1xyXG4gICAgICAgIHRoaXMubG9hZGVkTW9kcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm1vZE1hbmlmZXN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZU1vZHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb2RMb2FkT3JkZXIgPSBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2QgbWFuYWdlclxyXG4gICAgICovXHJcbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgTW9kIE1hbmFnZXInKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEaXNjb3ZlciBhdmFpbGFibGUgbW9kc1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZGlzY292ZXJNb2RzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9hZCBiYXNlIGdhbWUgbW9kIGJ5IGRlZmF1bHRcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2QoJ2Jhc2UtZ2FtZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2QgTWFuYWdlciBpbml0aWFsaXplZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIERpc2NvdmVyIGF2YWlsYWJsZSBtb2RzIGluIHRoZSBtb2RzIGRpcmVjdG9yeVxyXG4gICAgICovXHJcbiAgICBhc3luYyBkaXNjb3Zlck1vZHMoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgaGFyZGNvZGUgdGhlIGJhc2UgZ2FtZSBtb2RcclxuICAgICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBzY2FuIHRoZSBtb2RzIGRpcmVjdG9yeVxyXG4gICAgICAgICAgICBjb25zdCBiYXNlR2FtZU1hbmlmZXN0ID0gYXdhaXQgdGhpcy5sb2FkTW9kTWFuaWZlc3QoJ21vZHMvYmFzZS1nYW1lL21hbmlmZXN0Lmpzb24nKTtcclxuICAgICAgICAgICAgdGhpcy5tb2RNYW5pZmVzdHMuc2V0KCdiYXNlLWdhbWUnLCBiYXNlR2FtZU1hbmlmZXN0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEaXNjb3ZlcmVkICR7dGhpcy5tb2RNYW5pZmVzdHMuc2l6ZX0gbW9kKHMpYCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY292ZXJpbmcgbW9kczonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBtb2QgYnkgSURcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RJZCAtIFRoZSBtb2QgSUQgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxvYWRlZCBtb2QgZGF0YVxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkTW9kKG1vZElkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYExvYWRpbmcgbW9kOiAke21vZElkfWApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSB0aGlzLm1vZE1hbmlmZXN0cy5nZXQobW9kSWQpO1xyXG4gICAgICAgICAgICBpZiAoIW1hbmlmZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1vZCBtYW5pZmVzdCBub3QgZm91bmQ6ICR7bW9kSWR9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrRGVwZW5kZW5jaWVzKG1hbmlmZXN0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIExvYWQgbW9kIGRhdGFcclxuICAgICAgICAgICAgY29uc3QgbW9kRGF0YSA9IGF3YWl0IHRoaXMubG9hZE1vZERhdGEobWFuaWZlc3QpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTG9hZCBtb2QgYXNzZXRzXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZE1vZEFzc2V0cyhtYW5pZmVzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2FkIGxvY2FsaXphdGlvblxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2RMb2NhbGl6YXRpb24obWFuaWZlc3QpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gU3RvcmUgbG9hZGVkIG1vZFxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlZE1vZHMuc2V0KG1vZElkLCB7XHJcbiAgICAgICAgICAgICAgICBtYW5pZmVzdCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IG1vZERhdGEsXHJcbiAgICAgICAgICAgICAgICBhc3NldHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgbG9jYWxpemF0aW9uOiB7fVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9kcy5hZGQobW9kSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZExvYWRPcmRlci5wdXNoKG1vZElkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEVtaXQgbW9kIGxvYWRlZCBldmVudFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50U3lzdGVtLmVtaXQoJ21vZDpsb2FkZWQnLCB7XHJcbiAgICAgICAgICAgICAgICBtb2RJZCxcclxuICAgICAgICAgICAgICAgIG1hbmlmZXN0LFxyXG4gICAgICAgICAgICAgICAgZGF0YTogbW9kRGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2QgbG9hZGVkIHN1Y2Nlc3NmdWxseTogJHttb2RJZH1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZERhdGE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIG1vZCAke21vZElkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIG1vZCBtYW5pZmVzdCBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFBhdGggLSBQYXRoIHRvIHRoZSBtYW5pZmVzdCBmaWxlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbWFuaWZlc3QgZGF0YVxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkTW9kTWFuaWZlc3QobWFuaWZlc3RQYXRoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBtb2QgbWFuaWZlc3QgJHttYW5pZmVzdFBhdGh9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIG1vZCBkZXBlbmRlbmNpZXNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5pZmVzdCAtIFRoZSBtb2QgbWFuaWZlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY2hlY2tEZXBlbmRlbmNpZXMobWFuaWZlc3QpIHtcclxuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBtYW5pZmVzdC5kZXBlbmRlbmNpZXMgfHwgW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkTW9kcy5oYXMoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBkZXBlbmRlbmN5OiAke2RlcGVuZGVuY3l9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBtb2QgZGF0YSBmaWxlc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hbmlmZXN0IC0gVGhlIG1vZCBtYW5pZmVzdFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxvYWRlZCBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWRNb2REYXRhKG1hbmlmZXN0KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRhdGFGaWxlcyA9IG1hbmlmZXN0LmRhdGEgfHwge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwYXRoXSBvZiBPYmplY3QuZW50cmllcyhkYXRhRmlsZXMpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlyZWN0b3J5IC0gbG9hZCBhbGwgSlNPTiBmaWxlcyBpbiBkaXJlY3RvcnlcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBhd2FpdCB0aGlzLmxvYWREYXRhRGlyZWN0b3J5KHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBsb2FkIGRhdGEgZmlsZTogJHtwYXRofWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCBkYXRhIGZpbGUgJHtwYXRofTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhbGwgSlNPTiBmaWxlcyBpbiBhIGRpcmVjdG9yeVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdG9yeVBhdGggLSBQYXRoIHRvIHRoZSBkaXJlY3RvcnlcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIGZpbGVuYW1lIGtleXMgYW5kIGRhdGEgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWREYXRhRGlyZWN0b3J5KGRpcmVjdG9yeVBhdGgpIHtcclxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCByZXR1cm4gYW4gZW1wdHkgb2JqZWN0XHJcbiAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHNjYW4gdGhlIGRpcmVjdG9yeVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIG1vZCBhc3NldHNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5pZmVzdCAtIFRoZSBtb2QgbWFuaWZlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZE1vZEFzc2V0cyhtYW5pZmVzdCkge1xyXG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IG1hbmlmZXN0LmFzc2V0cyB8fCB7fTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IGxvZyB0aGUgYXNzZXQgcGF0aHNcclxuICAgICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgcHJlbG9hZCBhc3NldHNcclxuICAgICAgICBjb25zb2xlLmxvZygnTW9kIGFzc2V0czonLCBhc3NldHMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgbW9kIGxvY2FsaXphdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hbmlmZXN0IC0gVGhlIG1vZCBtYW5pZmVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkTW9kTG9jYWxpemF0aW9uKG1hbmlmZXN0KSB7XHJcbiAgICAgICAgY29uc3QgbG9jYWxpemF0aW9uID0gbWFuaWZlc3QubG9jYWxpemF0aW9uIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYW5nID0gbG9jYWxpemF0aW9uLmRlZmF1bHQgfHwgJ2VuJztcclxuICAgICAgICBjb25zdCBsYW5nUGF0aCA9IGxvY2FsaXphdGlvbi5wYXRoIHx8ICdsb2NhbGl6YXRpb24vJztcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2xhbmdQYXRofSR7ZGVmYXVsdExhbmd9Lmpzb25gKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYW5nRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgbG9jYWxpemF0aW9uOicsIGxhbmdEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgbG9jYWxpemF0aW9uOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGxvYWRlZCBtb2QgZGF0YVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZElkIC0gVGhlIG1vZCBJRFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG1vZCBkYXRhXHJcbiAgICAgKi9cclxuICAgIGdldE1vZERhdGEobW9kSWQpIHtcclxuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmxvYWRlZE1vZHMuZ2V0KG1vZElkKTtcclxuICAgICAgICByZXR1cm4gbW9kID8gbW9kLmRhdGEgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgbG9hZGVkIG1vZCBkYXRhIG1lcmdlZCB0b2dldGhlclxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gTWVyZ2VkIGRhdGEgZnJvbSBhbGwgbG9hZGVkIG1vZHNcclxuICAgICAqL1xyXG4gICAgZ2V0QWxsTW9kRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBtZXJnZWREYXRhID0ge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChjb25zdCBbbW9kSWQsIG1vZF0gb2YgdGhpcy5sb2FkZWRNb2RzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vZC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtZXJnZWREYXRhW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWREYXRhW2tleV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgZGF0YSAobW9kcyBsb2FkZWQgbGF0ZXIgb3ZlcnJpZGUgZWFybGllciBvbmVzKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZERhdGFba2V5XSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWREYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbWVyZ2VkRGF0YTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWN0aXZlIG1vZHNcclxuICAgICAqIEByZXR1cm5zIHtTZXR9IFNldCBvZiBhY3RpdmUgbW9kIElEc1xyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVNb2RzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU1vZHM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG1vZCBsb2FkIG9yZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIG1vZCBJRHMgaW4gbG9hZCBvcmRlclxyXG4gICAgICovXHJcbiAgICBnZXRNb2RMb2FkT3JkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kTG9hZE9yZGVyO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFVubG9hZCBhIG1vZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZElkIC0gVGhlIG1vZCBJRCB0byB1bmxvYWRcclxuICAgICAqL1xyXG4gICAgdW5sb2FkTW9kKG1vZElkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkTW9kcy5oYXMobW9kSWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkTW9kcy5kZWxldGUobW9kSWQpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vZHMuZGVsZXRlKG1vZElkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tb2RMb2FkT3JkZXIuaW5kZXhPZihtb2RJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZExvYWRPcmRlci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50U3lzdGVtLmVtaXQoJ21vZDp1bmxvYWRlZCcsIHsgbW9kSWQgfSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2QgdW5sb2FkZWQ6ICR7bW9kSWR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbG9hZCBhIG1vZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZElkIC0gVGhlIG1vZCBJRCB0byByZWxvYWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVsb2FkTW9kKG1vZElkKSB7XHJcbiAgICAgICAgdGhpcy51bmxvYWRNb2QobW9kSWQpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1vZChtb2RJZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93Lk1vZE1hbmFnZXIgPSBNb2RNYW5hZ2VyO1xyXG5cclxuLy8gRVMgTW9kdWxlIGV4cG9ydHNcclxuZXhwb3J0IHsgTW9kTWFuYWdlciB9OyAiXSwibmFtZXMiOlsiTW9kTWFuYWdlciIsImluaXRpYWxpemUiLCJjb25zb2xlIiwibG9nIiwiZGlzY292ZXJNb2RzIiwibG9hZE1vZCIsImJhc2VHYW1lTWFuaWZlc3QiLCJsb2FkTW9kTWFuaWZlc3QiLCJtb2RNYW5pZmVzdHMiLCJzZXQiLCJzaXplIiwiZXJyb3IiLCJtb2RJZCIsIm1hbmlmZXN0IiwiZ2V0IiwiRXJyb3IiLCJjaGVja0RlcGVuZGVuY2llcyIsIm1vZERhdGEiLCJsb2FkTW9kRGF0YSIsImxvYWRNb2RBc3NldHMiLCJsb2FkTW9kTG9jYWxpemF0aW9uIiwibG9hZGVkTW9kcyIsImRhdGEiLCJhc3NldHMiLCJsb2NhbGl6YXRpb24iLCJhY3RpdmVNb2RzIiwiYWRkIiwibW9kTG9hZE9yZGVyIiwicHVzaCIsImV2ZW50U3lzdGVtIiwiZW1pdCIsIm1hbmlmZXN0UGF0aCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImpzb24iLCJkZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmN5IiwiaGFzIiwiZGF0YUZpbGVzIiwia2V5IiwicGF0aCIsIk9iamVjdCIsImVudHJpZXMiLCJlbmRzV2l0aCIsImxvYWREYXRhRGlyZWN0b3J5Iiwid2FybiIsImRpcmVjdG9yeVBhdGgiLCJkZWZhdWx0TGFuZyIsImRlZmF1bHQiLCJsYW5nUGF0aCIsImxhbmdEYXRhIiwiZ2V0TW9kRGF0YSIsIm1vZCIsImdldEFsbE1vZERhdGEiLCJtZXJnZWREYXRhIiwidmFsdWUiLCJhc3NpZ24iLCJnZXRBY3RpdmVNb2RzIiwiZ2V0TW9kTG9hZE9yZGVyIiwidW5sb2FkTW9kIiwiZGVsZXRlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVsb2FkTW9kIiwiY29uc3RydWN0b3IiLCJhc3NldExvYWRlciIsIk1hcCIsIlNldCIsIndpbmRvdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/game-engine/core/ModManager.js\n"));

/***/ })

}]);