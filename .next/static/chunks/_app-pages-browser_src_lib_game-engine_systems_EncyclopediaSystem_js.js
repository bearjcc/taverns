"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_game-engine_systems_EncyclopediaSystem_js"],{

/***/ "(app-pages-browser)/./src/lib/game-engine/systems/EncyclopediaSystem.js":
/*!***********************************************************!*\
  !*** ./src/lib/game-engine/systems/EncyclopediaSystem.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncyclopediaSystem: () => (/* binding */ EncyclopediaSystem)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n/**\r\n * Encyclopedia System - Manages game data encyclopedia with crosslinking\r\n * Provides organized access to all game content including skills, items, species, etc.\r\n */ class EncyclopediaSystem {\n    /**\r\n   * Initialize the encyclopedia with all game data\r\n   * @param {Object} gameData - All loaded game data\r\n   */ async initialize(gameData) {\n        if (this.initialized) return;\n        try {\n            await this.loadSkillsData(gameData.skills || {});\n            await this.loadItemsData(gameData.items || {});\n            await this.loadSpeciesData(gameData.species || {});\n            await this.loadTraitsData(gameData.traits || {});\n            await this.loadLocationsData(gameData.locations || {});\n            await this.loadActionsData(gameData.actions || {});\n            this.buildCrossReferences();\n            this.buildSearchIndex();\n            this.initialized = true;\n            console.log('Encyclopedia system initialized with', this.entries.size, 'entries');\n        } catch (error) {\n            console.error('Failed to initialize encyclopedia system:', error);\n        }\n    }\n    /**\r\n   * Load skills data into encyclopedia\r\n   * @param {Object} skillsData - Skills configuration\r\n   */ async loadSkillsData(skillsData) {\n        const category = 'Skills';\n        this.categories.set(category, {\n            name: category,\n            description: 'All available skills and abilities',\n            icon: '‚öîÔ∏è',\n            entries: []\n        });\n        for (const [categoryName, categorySkills] of Object.entries(skillsData)){\n            for (const [skillName, skillData] of Object.entries(categorySkills)){\n                const entry = {\n                    id: \"skill_\".concat(skillName.toLowerCase().replace(/\\s+/g, '_')),\n                    type: 'skill',\n                    category: category,\n                    subcategory: categoryName,\n                    name: skillName,\n                    description: skillData.description || 'No description available.',\n                    data: skillData,\n                    tags: [\n                        categoryName.toLowerCase(),\n                        'skill'\n                    ],\n                    crossReferences: []\n                };\n                // Add requirements as cross-references\n                if (skillData.requires) {\n                    entry.requirements = skillData.requires;\n                    entry.crossReferences.push({\n                        type: 'requirement',\n                        target: \"skill_\".concat(skillData.requires.skill.toLowerCase().replace(/\\s+/g, '_')),\n                        description: \"Requires \".concat(skillData.requires.skill, \" level \").concat(skillData.requires.level)\n                    });\n                }\n                // Add sub-skills as cross-references\n                if (skillData.sub_skills) {\n                    for (const [subSkillName, subSkillData] of Object.entries(skillData.sub_skills)){\n                        entry.crossReferences.push({\n                            type: 'sub-skill',\n                            target: \"skill_\".concat(subSkillName.toLowerCase().replace(/\\s+/g, '_')),\n                            description: \"Sub-skill: \".concat(subSkillName)\n                        });\n                    }\n                }\n                this.entries.set(entry.id, entry);\n                this.categories.get(category).entries.push(entry.id);\n            }\n        }\n    }\n    /**\r\n   * Load items data into encyclopedia\r\n   * @param {Object} itemsData - Items configuration\r\n   */ async loadItemsData(itemsData) {\n        const category = 'Items';\n        this.categories.set(category, {\n            name: category,\n            description: 'All available items and equipment',\n            icon: 'üéí',\n            entries: []\n        });\n        for (const [itemId, itemData] of Object.entries(itemsData)){\n            const entry = {\n                id: \"item_\".concat(itemId),\n                type: 'item',\n                category: category,\n                name: itemData.displayName || itemData.name,\n                description: itemData.description || 'No description available.',\n                examineText: itemData.examineText || itemData.description,\n                icon: itemData.icon || 'üì¶',\n                data: itemData,\n                tags: [\n                    'item'\n                ],\n                crossReferences: []\n            };\n            // Add item type tags\n            if (itemData.stackable !== undefined) {\n                entry.tags.push(itemData.stackable ? 'stackable' : 'unique');\n            }\n            // Add equipment tags\n            if (itemData.equipmentType) {\n                entry.tags.push(itemData.equipmentType);\n                entry.subcategory = itemData.equipmentType;\n            }\n            this.entries.set(entry.id, entry);\n            this.categories.get(category).entries.push(entry.id);\n        }\n    }\n    /**\r\n   * Load species data into encyclopedia\r\n   * @param {Object} speciesData - Species configuration\r\n   */ async loadSpeciesData(speciesData) {\n        const category = 'Species';\n        this.categories.set(category, {\n            name: category,\n            description: 'All playable and non-playable species',\n            icon: 'üë•',\n            entries: []\n        });\n        for (const [categoryName, categorySpecies] of Object.entries(speciesData)){\n            for (const [speciesId, speciesData] of Object.entries(categorySpecies)){\n                const entry = {\n                    id: \"species_\".concat(speciesId),\n                    type: 'species',\n                    category: category,\n                    subcategory: categoryName,\n                    name: speciesData.name || speciesId,\n                    description: speciesData.description || 'No description available.',\n                    icon: 'üë§',\n                    data: speciesData,\n                    tags: [\n                        categoryName,\n                        'species'\n                    ],\n                    crossReferences: []\n                };\n                // Add profession cross-references\n                if (speciesData.professions) {\n                    for (const profession of speciesData.professions){\n                        entry.crossReferences.push({\n                            type: 'profession',\n                            target: \"skill_\".concat(profession.toLowerCase().replace(/\\s+/g, '_')),\n                            description: \"Can specialize in \".concat(profession)\n                        });\n                    }\n                }\n                this.entries.set(entry.id, entry);\n                this.categories.get(category).entries.push(entry.id);\n            }\n        }\n    }\n    /**\r\n   * Load traits data into encyclopedia\r\n   * @param {Object} traitsData - Traits configuration\r\n   */ async loadTraitsData(traitsData) {\n        const category = 'Traits';\n        this.categories.set(category, {\n            name: category,\n            description: 'Character traits and abilities',\n            icon: '‚ú®',\n            entries: []\n        });\n        for (const [traitId, traitData] of Object.entries(traitsData)){\n            const entry = {\n                id: \"trait_\".concat(traitId),\n                type: 'trait',\n                category: category,\n                name: traitData.name || traitId,\n                description: traitData.description || 'No description available.',\n                icon: '‚ú®',\n                data: traitData,\n                tags: [\n                    'trait'\n                ],\n                crossReferences: []\n            };\n            this.entries.set(entry.id, entry);\n            this.categories.get(category).entries.push(entry.id);\n        }\n    }\n    /**\r\n   * Load locations data into encyclopedia\r\n   * @param {Object} locationsData - Locations configuration\r\n   */ async loadLocationsData(locationsData) {\n        const category = 'Locations';\n        this.categories.set(category, {\n            name: category,\n            description: 'All game locations and areas',\n            icon: 'üó∫Ô∏è',\n            entries: []\n        });\n        for (const [locationId, locationData] of Object.entries(locationsData)){\n            const entry = {\n                id: \"location_\".concat(locationId),\n                type: 'location',\n                category: category,\n                name: locationData.name || locationId,\n                description: locationData.description || 'No description available.',\n                icon: 'üó∫Ô∏è',\n                data: locationData,\n                tags: [\n                    'location'\n                ],\n                crossReferences: []\n            };\n            this.entries.set(entry.id, entry);\n            this.categories.get(category).entries.push(entry.id);\n        }\n    }\n    /**\r\n   * Load actions data into encyclopedia\r\n   * @param {Object} actionsData - Actions configuration\r\n   */ async loadActionsData(actionsData) {\n        const category = 'Actions';\n        this.categories.set(category, {\n            name: category,\n            description: 'All available player actions',\n            icon: '‚ö°',\n            entries: []\n        });\n        for (const [actionId, actionData] of Object.entries(actionsData)){\n            const entry = {\n                id: \"action_\".concat(actionId),\n                type: 'action',\n                category: category,\n                name: actionData.name || actionId,\n                description: actionData.description || 'No description available.',\n                icon: '‚ö°',\n                data: actionData,\n                tags: [\n                    'action'\n                ],\n                crossReferences: []\n            };\n            // Add skill requirement cross-references\n            if (actionData.skillRequired) {\n                entry.crossReferences.push({\n                    type: 'skill-requirement',\n                    target: \"skill_\".concat(actionData.skillRequired.toLowerCase().replace(/\\s+/g, '_')),\n                    description: \"Requires \".concat(actionData.skillRequired, \" skill\")\n                });\n            }\n            // Add item requirement cross-references\n            if (actionData.itemsRequired) {\n                for (const itemId of Object.keys(actionData.itemsRequired)){\n                    entry.crossReferences.push({\n                        type: 'item-requirement',\n                        target: \"item_\".concat(itemId),\n                        description: \"Requires \".concat(itemId)\n                    });\n                }\n            }\n            this.entries.set(entry.id, entry);\n            this.categories.get(category).entries.push(entry.id);\n        }\n    }\n    /**\r\n   * Build cross-references between entries\r\n   */ buildCrossReferences() {\n        for (const [entryId, entry] of this.entries){\n            for (const crossRef of entry.crossReferences){\n                const targetEntry = this.entries.get(crossRef.target);\n                if (targetEntry) {\n                    if (!targetEntry.crossReferences) {\n                        targetEntry.crossReferences = [];\n                    }\n                    targetEntry.crossReferences.push({\n                        type: 'reverse',\n                        target: entryId,\n                        description: \"Referenced by \".concat(entry.name)\n                    });\n                }\n            }\n        }\n    }\n    /**\r\n   * Build search index for quick lookups\r\n   */ buildSearchIndex() {\n        for (const [entryId, entry] of this.entries){\n            // Index by name\n            this.addToSearchIndex(entry.name.toLowerCase(), entryId);\n            // Index by description\n            this.addToSearchIndex(entry.description.toLowerCase(), entryId);\n            // Index by tags\n            for (const tag of entry.tags){\n                this.addToSearchIndex(tag.toLowerCase(), entryId);\n            }\n            // Index by subcategory\n            if (entry.subcategory) {\n                this.addToSearchIndex(entry.subcategory.toLowerCase(), entryId);\n            }\n        }\n    }\n    /**\r\n   * Add term to search index\r\n   * @param {string} term - Search term\r\n   * @param {string} entryId - Entry ID to index\r\n   */ addToSearchIndex(term, entryId) {\n        const words = term.split(/\\s+/);\n        for (const word of words){\n            if (word.length >= 2) {\n                if (!this.searchIndex.has(word)) {\n                    this.searchIndex.set(word, new Set());\n                }\n                this.searchIndex.get(word).add(entryId);\n            }\n        }\n    }\n    /**\r\n   * Search encyclopedia entries\r\n   * @param {string} query - Search query\r\n   * @returns {Array} Array of matching entries\r\n   */ search(query) {\n        if (!query || query.length < 2) return [];\n        const queryLower = query.toLowerCase();\n        const queryWords = queryLower.split(/\\s+/);\n        const results = new Map();\n        for (const word of queryWords){\n            if (word.length >= 2) {\n                const matches = this.searchIndex.get(word);\n                if (matches) {\n                    for (const entryId of matches){\n                        const entry = this.entries.get(entryId);\n                        if (entry) {\n                            const score = results.get(entryId) || 0;\n                            results.set(entryId, score + 1);\n                        }\n                    }\n                }\n            }\n        }\n        // Sort by relevance score\n        return Array.from(results.entries()).sort((a, b)=>b[1] - a[1]).map((param)=>{\n            let [entryId] = param;\n            return this.entries.get(entryId);\n        }).filter(Boolean);\n    }\n    /**\r\n   * Get entry by ID\r\n   * @param {string} entryId - Entry ID\r\n   * @returns {Object|null} Entry data or null if not found\r\n   */ getEntry(entryId) {\n        return this.entries.get(entryId) || null;\n    }\n    /**\r\n   * Get all categories\r\n   * @returns {Array} Array of category objects\r\n   */ getCategories() {\n        return Array.from(this.categories.values());\n    }\n    /**\r\n   * Get entries by category\r\n   * @param {string} categoryName - Category name\r\n   * @returns {Array} Array of entries in category\r\n   */ getEntriesByCategory(categoryName) {\n        const category = this.categories.get(categoryName);\n        if (!category) return [];\n        return category.entries.map((entryId)=>this.entries.get(entryId)).filter(Boolean);\n    }\n    /**\r\n   * Get cross-references for an entry\r\n   * @param {string} entryId - Entry ID\r\n   * @returns {Array} Array of cross-reference objects\r\n   */ getCrossReferences(entryId) {\n        const entry = this.entries.get(entryId);\n        if (!entry || !entry.crossReferences) return [];\n        return entry.crossReferences.map((crossRef)=>({\n                ...crossRef,\n                targetEntry: this.entries.get(crossRef.target)\n            })).filter((crossRef)=>crossRef.targetEntry);\n    }\n    /**\r\n   * Get encyclopedia statistics\r\n   * @returns {Object} Statistics about the encyclopedia\r\n   */ getStatistics() {\n        const stats = {\n            totalEntries: this.entries.size,\n            categories: this.categories.size,\n            searchIndexSize: this.searchIndex.size\n        };\n        for (const [categoryName, category] of this.categories){\n            stats[categoryName] = category.entries.length;\n        }\n        return stats;\n    }\n    constructor(){\n        this.entries = new Map();\n        this.categories = new Map();\n        this.searchIndex = new Map();\n        this.crossReferences = new Map();\n        this.initialized = false;\n    }\n}\n// Export for use in other modules\nif ( true && module.exports) {\n    module.exports = EncyclopediaSystem;\n}\nif (true) window.EncyclopediaSystem = EncyclopediaSystem;\n// ES Module exports\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZS1lbmdpbmUvc3lzdGVtcy9FbmN5Y2xvcGVkaWFTeXN0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQTtJQVNKOzs7R0FHQyxHQUNELE1BQU1DLFdBQVdDLFFBQVEsRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQ0MsV0FBVyxFQUFFO1FBRXRCLElBQUk7WUFDRixNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDRixTQUFTRyxNQUFNLElBQUksQ0FBQztZQUM5QyxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDSixTQUFTSyxLQUFLLElBQUksQ0FBQztZQUM1QyxNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDTixTQUFTTyxPQUFPLElBQUksQ0FBQztZQUNoRCxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDUixTQUFTUyxNQUFNLElBQUksQ0FBQztZQUM5QyxNQUFNLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNWLFNBQVNXLFNBQVMsSUFBSSxDQUFDO1lBQ3BELE1BQU0sSUFBSSxDQUFDQyxlQUFlLENBQUNaLFNBQVNhLE9BQU8sSUFBSSxDQUFDO1lBRWhELElBQUksQ0FBQ0Msb0JBQW9CO1lBQ3pCLElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ3JCLElBQUksQ0FBQ2QsV0FBVyxHQUFHO1lBRW5CZSxRQUFRQyxHQUFHLENBQUMsd0NBQXdDLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLEVBQUU7UUFDekUsRUFBRSxPQUFPQyxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyw2Q0FBNkNBO1FBQzdEO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCxNQUFNbEIsZUFBZW1CLFVBQVUsRUFBRTtRQUMvQixNQUFNQyxXQUFXO1FBQ2pCLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxHQUFHLENBQUNGLFVBQVU7WUFDNUJHLE1BQU1IO1lBQ05JLGFBQWE7WUFDYkMsTUFBTTtZQUNOVCxTQUFTLEVBQUU7UUFDYjtR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O0lBL2JBRyxhQUFjO1FBQ1osSUFBSSxDQUFDbEcsT0FBTyxHQUFHLElBQUk4RTtRQUNuQixJQUFJLENBQUN6RSxVQUFVLEdBQUcsSUFBSXlFO1FBQ3RCLElBQUksQ0FBQ1QsV0FBVyxHQUFHLElBQUlTO1FBQ3ZCLElBQUksQ0FBQ3ZELGVBQWUsR0FBRyxJQUFJdUQ7UUFDM0IsSUFBSSxDQUFDL0YsV0FBVyxHQUFHO0lBQ3JCO0FBMGJGO0FBRUEsa0NBQWtDO0FBQ2xDLElBQUksS0FBNkIsSUFBSW9ILE9BQU9DLE9BQU8sRUFBRTtJQUNuREQsT0FBT0MsT0FBTyxHQUFHeEg7QUFDbkI7QUFFQSxJQUFJLElBQTZCLEVBQUV5SCxPQUFPekgsa0JBQWtCLEdBQUdBO0FBRS9ELG9CQUFvQjtBQUNVIiwic291cmNlcyI6WyJDOlxcR2l0SHViXFxTZWxmXFx0YXZlcm5zXFxzcmNcXGxpYlxcZ2FtZS1lbmdpbmVcXHN5c3RlbXNcXEVuY3ljbG9wZWRpYVN5c3RlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRW5jeWNsb3BlZGlhIFN5c3RlbSAtIE1hbmFnZXMgZ2FtZSBkYXRhIGVuY3ljbG9wZWRpYSB3aXRoIGNyb3NzbGlua2luZ1xyXG4gKiBQcm92aWRlcyBvcmdhbml6ZWQgYWNjZXNzIHRvIGFsbCBnYW1lIGNvbnRlbnQgaW5jbHVkaW5nIHNraWxscywgaXRlbXMsIHNwZWNpZXMsIGV0Yy5cclxuICovXHJcbmNsYXNzIEVuY3ljbG9wZWRpYVN5c3RlbSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmVudHJpZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmNhdGVnb3JpZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnNlYXJjaEluZGV4ID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5jcm9zc1JlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBlbmN5Y2xvcGVkaWEgd2l0aCBhbGwgZ2FtZSBkYXRhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGdhbWVEYXRhIC0gQWxsIGxvYWRlZCBnYW1lIGRhdGFcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplKGdhbWVEYXRhKSB7XHJcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZFNraWxsc0RhdGEoZ2FtZURhdGEuc2tpbGxzIHx8IHt9KTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkSXRlbXNEYXRhKGdhbWVEYXRhLml0ZW1zIHx8IHt9KTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkU3BlY2llc0RhdGEoZ2FtZURhdGEuc3BlY2llcyB8fCB7fSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZFRyYWl0c0RhdGEoZ2FtZURhdGEudHJhaXRzIHx8IHt9KTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkTG9jYXRpb25zRGF0YShnYW1lRGF0YS5sb2NhdGlvbnMgfHwge30pO1xyXG4gICAgICBhd2FpdCB0aGlzLmxvYWRBY3Rpb25zRGF0YShnYW1lRGF0YS5hY3Rpb25zIHx8IHt9KTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuYnVpbGRDcm9zc1JlZmVyZW5jZXMoKTtcclxuICAgICAgdGhpcy5idWlsZFNlYXJjaEluZGV4KCk7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0VuY3ljbG9wZWRpYSBzeXN0ZW0gaW5pdGlhbGl6ZWQgd2l0aCcsIHRoaXMuZW50cmllcy5zaXplLCAnZW50cmllcycpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgZW5jeWNsb3BlZGlhIHN5c3RlbTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIHNraWxscyBkYXRhIGludG8gZW5jeWNsb3BlZGlhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNraWxsc0RhdGEgLSBTa2lsbHMgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWRTa2lsbHNEYXRhKHNraWxsc0RhdGEpIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gJ1NraWxscyc7XHJcbiAgICB0aGlzLmNhdGVnb3JpZXMuc2V0KGNhdGVnb3J5LCB7XHJcbiAgICAgIG5hbWU6IGNhdGVnb3J5LFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0FsbCBhdmFpbGFibGUgc2tpbGxzIGFuZCBhYmlsaXRpZXMnLFxyXG4gICAgICBpY29uOiAn4pqU77iPJyxcclxuICAgICAgZW50cmllczogW11cclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2NhdGVnb3J5TmFtZSwgY2F0ZWdvcnlTa2lsbHNdIG9mIE9iamVjdC5lbnRyaWVzKHNraWxsc0RhdGEpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW3NraWxsTmFtZSwgc2tpbGxEYXRhXSBvZiBPYmplY3QuZW50cmllcyhjYXRlZ29yeVNraWxscykpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHtcclxuICAgICAgICAgIGlkOiBgc2tpbGxfJHtza2lsbE5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICdfJyl9YCxcclxuICAgICAgICAgIHR5cGU6ICdza2lsbCcsXHJcbiAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnksXHJcbiAgICAgICAgICBzdWJjYXRlZ29yeTogY2F0ZWdvcnlOYW1lLFxyXG4gICAgICAgICAgbmFtZTogc2tpbGxOYW1lLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IHNraWxsRGF0YS5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlLicsXHJcbiAgICAgICAgICBkYXRhOiBza2lsbERhdGEsXHJcbiAgICAgICAgICB0YWdzOiBbY2F0ZWdvcnlOYW1lLnRvTG93ZXJDYXNlKCksICdza2lsbCddLFxyXG4gICAgICAgICAgY3Jvc3NSZWZlcmVuY2VzOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFkZCByZXF1aXJlbWVudHMgYXMgY3Jvc3MtcmVmZXJlbmNlc1xyXG4gICAgICAgIGlmIChza2lsbERhdGEucmVxdWlyZXMpIHtcclxuICAgICAgICAgIGVudHJ5LnJlcXVpcmVtZW50cyA9IHNraWxsRGF0YS5yZXF1aXJlcztcclxuICAgICAgICAgIGVudHJ5LmNyb3NzUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogJ3JlcXVpcmVtZW50JyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBgc2tpbGxfJHtza2lsbERhdGEucmVxdWlyZXMuc2tpbGwudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICdfJyl9YCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZXF1aXJlcyAke3NraWxsRGF0YS5yZXF1aXJlcy5za2lsbH0gbGV2ZWwgJHtza2lsbERhdGEucmVxdWlyZXMubGV2ZWx9YFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgc3ViLXNraWxscyBhcyBjcm9zcy1yZWZlcmVuY2VzXHJcbiAgICAgICAgaWYgKHNraWxsRGF0YS5zdWJfc2tpbGxzKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IFtzdWJTa2lsbE5hbWUsIHN1YlNraWxsRGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoc2tpbGxEYXRhLnN1Yl9za2lsbHMpKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmNyb3NzUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnc3ViLXNraWxsJyxcclxuICAgICAgICAgICAgICB0YXJnZXQ6IGBza2lsbF8ke3N1YlNraWxsTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJ18nKX1gLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgU3ViLXNraWxsOiAke3N1YlNraWxsTmFtZX1gXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbnRyaWVzLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcy5nZXQoY2F0ZWdvcnkpLmVudHJpZXMucHVzaChlbnRyeS5pZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgaXRlbXMgZGF0YSBpbnRvIGVuY3ljbG9wZWRpYVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtc0RhdGEgLSBJdGVtcyBjb25maWd1cmF0aW9uXHJcbiAgICovXHJcbiAgYXN5bmMgbG9hZEl0ZW1zRGF0YShpdGVtc0RhdGEpIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gJ0l0ZW1zJztcclxuICAgIHRoaXMuY2F0ZWdvcmllcy5zZXQoY2F0ZWdvcnksIHtcclxuICAgICAgbmFtZTogY2F0ZWdvcnksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWxsIGF2YWlsYWJsZSBpdGVtcyBhbmQgZXF1aXBtZW50JyxcclxuICAgICAgaWNvbjogJ/CfjpInLFxyXG4gICAgICBlbnRyaWVzOiBbXVxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbaXRlbUlkLCBpdGVtRGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoaXRlbXNEYXRhKSkge1xyXG4gICAgICBjb25zdCBlbnRyeSA9IHtcclxuICAgICAgICBpZDogYGl0ZW1fJHtpdGVtSWR9YCxcclxuICAgICAgICB0eXBlOiAnaXRlbScsXHJcbiAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5LFxyXG4gICAgICAgIG5hbWU6IGl0ZW1EYXRhLmRpc3BsYXlOYW1lIHx8IGl0ZW1EYXRhLm5hbWUsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGl0ZW1EYXRhLmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBhdmFpbGFibGUuJyxcclxuICAgICAgICBleGFtaW5lVGV4dDogaXRlbURhdGEuZXhhbWluZVRleHQgfHwgaXRlbURhdGEuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgaWNvbjogaXRlbURhdGEuaWNvbiB8fCAn8J+TpicsXHJcbiAgICAgICAgZGF0YTogaXRlbURhdGEsXHJcbiAgICAgICAgdGFnczogWydpdGVtJ10sXHJcbiAgICAgICAgY3Jvc3NSZWZlcmVuY2VzOiBbXVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQWRkIGl0ZW0gdHlwZSB0YWdzXHJcbiAgICAgIGlmIChpdGVtRGF0YS5zdGFja2FibGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVudHJ5LnRhZ3MucHVzaChpdGVtRGF0YS5zdGFja2FibGUgPyAnc3RhY2thYmxlJyA6ICd1bmlxdWUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGVxdWlwbWVudCB0YWdzXHJcbiAgICAgIGlmIChpdGVtRGF0YS5lcXVpcG1lbnRUeXBlKSB7XHJcbiAgICAgICAgZW50cnkudGFncy5wdXNoKGl0ZW1EYXRhLmVxdWlwbWVudFR5cGUpO1xyXG4gICAgICAgIGVudHJ5LnN1YmNhdGVnb3J5ID0gaXRlbURhdGEuZXF1aXBtZW50VHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5lbnRyaWVzLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICB0aGlzLmNhdGVnb3JpZXMuZ2V0KGNhdGVnb3J5KS5lbnRyaWVzLnB1c2goZW50cnkuaWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBzcGVjaWVzIGRhdGEgaW50byBlbmN5Y2xvcGVkaWFcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY2llc0RhdGEgLSBTcGVjaWVzIGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBhc3luYyBsb2FkU3BlY2llc0RhdGEoc3BlY2llc0RhdGEpIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gJ1NwZWNpZXMnO1xyXG4gICAgdGhpcy5jYXRlZ29yaWVzLnNldChjYXRlZ29yeSwge1xyXG4gICAgICBuYW1lOiBjYXRlZ29yeSxcclxuICAgICAgZGVzY3JpcHRpb246ICdBbGwgcGxheWFibGUgYW5kIG5vbi1wbGF5YWJsZSBzcGVjaWVzJyxcclxuICAgICAgaWNvbjogJ/CfkaUnLFxyXG4gICAgICBlbnRyaWVzOiBbXVxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbY2F0ZWdvcnlOYW1lLCBjYXRlZ29yeVNwZWNpZXNdIG9mIE9iamVjdC5lbnRyaWVzKHNwZWNpZXNEYXRhKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IFtzcGVjaWVzSWQsIHNwZWNpZXNEYXRhXSBvZiBPYmplY3QuZW50cmllcyhjYXRlZ29yeVNwZWNpZXMpKSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSB7XHJcbiAgICAgICAgICBpZDogYHNwZWNpZXNfJHtzcGVjaWVzSWR9YCxcclxuICAgICAgICAgIHR5cGU6ICdzcGVjaWVzJyxcclxuICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcclxuICAgICAgICAgIHN1YmNhdGVnb3J5OiBjYXRlZ29yeU5hbWUsXHJcbiAgICAgICAgICBuYW1lOiBzcGVjaWVzRGF0YS5uYW1lIHx8IHNwZWNpZXNJZCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBzcGVjaWVzRGF0YS5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlLicsXHJcbiAgICAgICAgICBpY29uOiAn8J+RpCcsXHJcbiAgICAgICAgICBkYXRhOiBzcGVjaWVzRGF0YSxcclxuICAgICAgICAgIHRhZ3M6IFtjYXRlZ29yeU5hbWUsICdzcGVjaWVzJ10sXHJcbiAgICAgICAgICBjcm9zc1JlZmVyZW5jZXM6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHByb2Zlc3Npb24gY3Jvc3MtcmVmZXJlbmNlc1xyXG4gICAgICAgIGlmIChzcGVjaWVzRGF0YS5wcm9mZXNzaW9ucykge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBwcm9mZXNzaW9uIG9mIHNwZWNpZXNEYXRhLnByb2Zlc3Npb25zKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmNyb3NzUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiAncHJvZmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgdGFyZ2V0OiBgc2tpbGxfJHtwcm9mZXNzaW9uLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnXycpfWAsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDYW4gc3BlY2lhbGl6ZSBpbiAke3Byb2Zlc3Npb259YFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZW50cmllcy5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICB0aGlzLmNhdGVnb3JpZXMuZ2V0KGNhdGVnb3J5KS5lbnRyaWVzLnB1c2goZW50cnkuaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIHRyYWl0cyBkYXRhIGludG8gZW5jeWNsb3BlZGlhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYWl0c0RhdGEgLSBUcmFpdHMgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWRUcmFpdHNEYXRhKHRyYWl0c0RhdGEpIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gJ1RyYWl0cyc7XHJcbiAgICB0aGlzLmNhdGVnb3JpZXMuc2V0KGNhdGVnb3J5LCB7XHJcbiAgICAgIG5hbWU6IGNhdGVnb3J5LFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0NoYXJhY3RlciB0cmFpdHMgYW5kIGFiaWxpdGllcycsXHJcbiAgICAgIGljb246ICfinKgnLFxyXG4gICAgICBlbnRyaWVzOiBbXVxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbdHJhaXRJZCwgdHJhaXREYXRhXSBvZiBPYmplY3QuZW50cmllcyh0cmFpdHNEYXRhKSkge1xyXG4gICAgICBjb25zdCBlbnRyeSA9IHtcclxuICAgICAgICBpZDogYHRyYWl0XyR7dHJhaXRJZH1gLFxyXG4gICAgICAgIHR5cGU6ICd0cmFpdCcsXHJcbiAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5LFxyXG4gICAgICAgIG5hbWU6IHRyYWl0RGF0YS5uYW1lIHx8IHRyYWl0SWQsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IHRyYWl0RGF0YS5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlLicsXHJcbiAgICAgICAgaWNvbjogJ+KcqCcsXHJcbiAgICAgICAgZGF0YTogdHJhaXREYXRhLFxyXG4gICAgICAgIHRhZ3M6IFsndHJhaXQnXSxcclxuICAgICAgICBjcm9zc1JlZmVyZW5jZXM6IFtdXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmVudHJpZXMuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XHJcbiAgICAgIHRoaXMuY2F0ZWdvcmllcy5nZXQoY2F0ZWdvcnkpLmVudHJpZXMucHVzaChlbnRyeS5pZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGxvY2F0aW9ucyBkYXRhIGludG8gZW5jeWNsb3BlZGlhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uc0RhdGEgLSBMb2NhdGlvbnMgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWRMb2NhdGlvbnNEYXRhKGxvY2F0aW9uc0RhdGEpIHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gJ0xvY2F0aW9ucyc7XHJcbiAgICB0aGlzLmNhdGVnb3JpZXMuc2V0KGNhdGVnb3J5LCB7XHJcbiAgICAgIG5hbWU6IGNhdGVnb3J5LFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0FsbCBnYW1lIGxvY2F0aW9ucyBhbmQgYXJlYXMnLFxyXG4gICAgICBpY29uOiAn8J+Xuu+4jycsXHJcbiAgICAgIGVudHJpZXM6IFtdXHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtsb2NhdGlvbklkLCBsb2NhdGlvbkRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2F0aW9uc0RhdGEpKSB7XHJcbiAgICAgIGNvbnN0IGVudHJ5ID0ge1xyXG4gICAgICAgIGlkOiBgbG9jYXRpb25fJHtsb2NhdGlvbklkfWAsXHJcbiAgICAgICAgdHlwZTogJ2xvY2F0aW9uJyxcclxuICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnksXHJcbiAgICAgICAgbmFtZTogbG9jYXRpb25EYXRhLm5hbWUgfHwgbG9jYXRpb25JZCxcclxuICAgICAgICBkZXNjcmlwdGlvbjogbG9jYXRpb25EYXRhLmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBhdmFpbGFibGUuJyxcclxuICAgICAgICBpY29uOiAn8J+Xuu+4jycsXHJcbiAgICAgICAgZGF0YTogbG9jYXRpb25EYXRhLFxyXG4gICAgICAgIHRhZ3M6IFsnbG9jYXRpb24nXSxcclxuICAgICAgICBjcm9zc1JlZmVyZW5jZXM6IFtdXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmVudHJpZXMuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XHJcbiAgICAgIHRoaXMuY2F0ZWdvcmllcy5nZXQoY2F0ZWdvcnkpLmVudHJpZXMucHVzaChlbnRyeS5pZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGFjdGlvbnMgZGF0YSBpbnRvIGVuY3ljbG9wZWRpYVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25zRGF0YSAtIEFjdGlvbnMgY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWRBY3Rpb25zRGF0YShhY3Rpb25zRGF0YSkge1xyXG4gICAgY29uc3QgY2F0ZWdvcnkgPSAnQWN0aW9ucyc7XHJcbiAgICB0aGlzLmNhdGVnb3JpZXMuc2V0KGNhdGVnb3J5LCB7XHJcbiAgICAgIG5hbWU6IGNhdGVnb3J5LFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0FsbCBhdmFpbGFibGUgcGxheWVyIGFjdGlvbnMnLFxyXG4gICAgICBpY29uOiAn4pqhJyxcclxuICAgICAgZW50cmllczogW11cclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAoY29uc3QgW2FjdGlvbklkLCBhY3Rpb25EYXRhXSBvZiBPYmplY3QuZW50cmllcyhhY3Rpb25zRGF0YSkpIHtcclxuICAgICAgY29uc3QgZW50cnkgPSB7XHJcbiAgICAgICAgaWQ6IGBhY3Rpb25fJHthY3Rpb25JZH1gLFxyXG4gICAgICAgIHR5cGU6ICdhY3Rpb24nLFxyXG4gICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcclxuICAgICAgICBuYW1lOiBhY3Rpb25EYXRhLm5hbWUgfHwgYWN0aW9uSWQsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGFjdGlvbkRhdGEuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZS4nLFxyXG4gICAgICAgIGljb246ICfimqEnLFxyXG4gICAgICAgIGRhdGE6IGFjdGlvbkRhdGEsXHJcbiAgICAgICAgdGFnczogWydhY3Rpb24nXSxcclxuICAgICAgICBjcm9zc1JlZmVyZW5jZXM6IFtdXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBZGQgc2tpbGwgcmVxdWlyZW1lbnQgY3Jvc3MtcmVmZXJlbmNlc1xyXG4gICAgICBpZiAoYWN0aW9uRGF0YS5za2lsbFJlcXVpcmVkKSB7XHJcbiAgICAgICAgZW50cnkuY3Jvc3NSZWZlcmVuY2VzLnB1c2goe1xyXG4gICAgICAgICAgdHlwZTogJ3NraWxsLXJlcXVpcmVtZW50JyxcclxuICAgICAgICAgIHRhcmdldDogYHNraWxsXyR7YWN0aW9uRGF0YS5za2lsbFJlcXVpcmVkLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnXycpfWAsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFJlcXVpcmVzICR7YWN0aW9uRGF0YS5za2lsbFJlcXVpcmVkfSBza2lsbGBcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGl0ZW0gcmVxdWlyZW1lbnQgY3Jvc3MtcmVmZXJlbmNlc1xyXG4gICAgICBpZiAoYWN0aW9uRGF0YS5pdGVtc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtSWQgb2YgT2JqZWN0LmtleXMoYWN0aW9uRGF0YS5pdGVtc1JlcXVpcmVkKSkge1xyXG4gICAgICAgICAgZW50cnkuY3Jvc3NSZWZlcmVuY2VzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAnaXRlbS1yZXF1aXJlbWVudCcsXHJcbiAgICAgICAgICAgIHRhcmdldDogYGl0ZW1fJHtpdGVtSWR9YCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZXF1aXJlcyAke2l0ZW1JZH1gXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZW50cmllcy5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgdGhpcy5jYXRlZ29yaWVzLmdldChjYXRlZ29yeSkuZW50cmllcy5wdXNoKGVudHJ5LmlkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkIGNyb3NzLXJlZmVyZW5jZXMgYmV0d2VlbiBlbnRyaWVzXHJcbiAgICovXHJcbiAgYnVpbGRDcm9zc1JlZmVyZW5jZXMoKSB7XHJcbiAgICBmb3IgKGNvbnN0IFtlbnRyeUlkLCBlbnRyeV0gb2YgdGhpcy5lbnRyaWVzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY3Jvc3NSZWYgb2YgZW50cnkuY3Jvc3NSZWZlcmVuY2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RW50cnkgPSB0aGlzLmVudHJpZXMuZ2V0KGNyb3NzUmVmLnRhcmdldCk7XHJcbiAgICAgICAgaWYgKHRhcmdldEVudHJ5KSB7XHJcbiAgICAgICAgICBpZiAoIXRhcmdldEVudHJ5LmNyb3NzUmVmZXJlbmNlcykge1xyXG4gICAgICAgICAgICB0YXJnZXRFbnRyeS5jcm9zc1JlZmVyZW5jZXMgPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhcmdldEVudHJ5LmNyb3NzUmVmZXJlbmNlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogJ3JldmVyc2UnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IGVudHJ5SWQsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUmVmZXJlbmNlZCBieSAke2VudHJ5Lm5hbWV9YFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZCBzZWFyY2ggaW5kZXggZm9yIHF1aWNrIGxvb2t1cHNcclxuICAgKi9cclxuICBidWlsZFNlYXJjaEluZGV4KCkge1xyXG4gICAgZm9yIChjb25zdCBbZW50cnlJZCwgZW50cnldIG9mIHRoaXMuZW50cmllcykge1xyXG4gICAgICAvLyBJbmRleCBieSBuYW1lXHJcbiAgICAgIHRoaXMuYWRkVG9TZWFyY2hJbmRleChlbnRyeS5uYW1lLnRvTG93ZXJDYXNlKCksIGVudHJ5SWQpO1xyXG4gICAgICBcclxuICAgICAgLy8gSW5kZXggYnkgZGVzY3JpcHRpb25cclxuICAgICAgdGhpcy5hZGRUb1NlYXJjaEluZGV4KGVudHJ5LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCksIGVudHJ5SWQpO1xyXG4gICAgICBcclxuICAgICAgLy8gSW5kZXggYnkgdGFnc1xyXG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiBlbnRyeS50YWdzKSB7XHJcbiAgICAgICAgdGhpcy5hZGRUb1NlYXJjaEluZGV4KHRhZy50b0xvd2VyQ2FzZSgpLCBlbnRyeUlkKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSW5kZXggYnkgc3ViY2F0ZWdvcnlcclxuICAgICAgaWYgKGVudHJ5LnN1YmNhdGVnb3J5KSB7XHJcbiAgICAgICAgdGhpcy5hZGRUb1NlYXJjaEluZGV4KGVudHJ5LnN1YmNhdGVnb3J5LnRvTG93ZXJDYXNlKCksIGVudHJ5SWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgdGVybSB0byBzZWFyY2ggaW5kZXhcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVybSAtIFNlYXJjaCB0ZXJtXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5SWQgLSBFbnRyeSBJRCB0byBpbmRleFxyXG4gICAqL1xyXG4gIGFkZFRvU2VhcmNoSW5kZXgodGVybSwgZW50cnlJZCkge1xyXG4gICAgY29uc3Qgd29yZHMgPSB0ZXJtLnNwbGl0KC9cXHMrLyk7XHJcbiAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcclxuICAgICAgaWYgKHdvcmQubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VhcmNoSW5kZXguaGFzKHdvcmQpKSB7XHJcbiAgICAgICAgICB0aGlzLnNlYXJjaEluZGV4LnNldCh3b3JkLCBuZXcgU2V0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlYXJjaEluZGV4LmdldCh3b3JkKS5hZGQoZW50cnlJZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaCBlbmN5Y2xvcGVkaWEgZW50cmllc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFNlYXJjaCBxdWVyeVxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbWF0Y2hpbmcgZW50cmllc1xyXG4gICAqL1xyXG4gIHNlYXJjaChxdWVyeSkge1xyXG4gICAgaWYgKCFxdWVyeSB8fCBxdWVyeS5sZW5ndGggPCAyKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3QgcXVlcnlMb3dlciA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBxdWVyeVdvcmRzID0gcXVlcnlMb3dlci5zcGxpdCgvXFxzKy8pO1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHdvcmQgb2YgcXVlcnlXb3Jkcykge1xyXG4gICAgICBpZiAod29yZC5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLnNlYXJjaEluZGV4LmdldCh3b3JkKTtcclxuICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBlbnRyeUlkIG9mIG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmVudHJpZXMuZ2V0KGVudHJ5SWQpO1xyXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IHJlc3VsdHMuZ2V0KGVudHJ5SWQpIHx8IDA7XHJcbiAgICAgICAgICAgICAgcmVzdWx0cy5zZXQoZW50cnlJZCwgc2NvcmUgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgYnkgcmVsZXZhbmNlIHNjb3JlXHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHRzLmVudHJpZXMoKSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxyXG4gICAgICAubWFwKChbZW50cnlJZF0pID0+IHRoaXMuZW50cmllcy5nZXQoZW50cnlJZCkpXHJcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZW50cnkgYnkgSURcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlJZCAtIEVudHJ5IElEXHJcbiAgICogQHJldHVybnMge09iamVjdHxudWxsfSBFbnRyeSBkYXRhIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICovXHJcbiAgZ2V0RW50cnkoZW50cnlJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZW50cmllcy5nZXQoZW50cnlJZCkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgY2F0ZWdvcmllc1xyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgY2F0ZWdvcnkgb2JqZWN0c1xyXG4gICAqL1xyXG4gIGdldENhdGVnb3JpZXMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNhdGVnb3JpZXMudmFsdWVzKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGVudHJpZXMgYnkgY2F0ZWdvcnlcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnlOYW1lIC0gQ2F0ZWdvcnkgbmFtZVxyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZW50cmllcyBpbiBjYXRlZ29yeVxyXG4gICAqL1xyXG4gIGdldEVudHJpZXNCeUNhdGVnb3J5KGNhdGVnb3J5TmFtZSkge1xyXG4gICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmNhdGVnb3JpZXMuZ2V0KGNhdGVnb3J5TmFtZSk7XHJcbiAgICBpZiAoIWNhdGVnb3J5KSByZXR1cm4gW107XHJcblxyXG4gICAgcmV0dXJuIGNhdGVnb3J5LmVudHJpZXNcclxuICAgICAgLm1hcChlbnRyeUlkID0+IHRoaXMuZW50cmllcy5nZXQoZW50cnlJZCkpXHJcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3Jvc3MtcmVmZXJlbmNlcyBmb3IgYW4gZW50cnlcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlJZCAtIEVudHJ5IElEXHJcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBjcm9zcy1yZWZlcmVuY2Ugb2JqZWN0c1xyXG4gICAqL1xyXG4gIGdldENyb3NzUmVmZXJlbmNlcyhlbnRyeUlkKSB7XHJcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllcy5nZXQoZW50cnlJZCk7XHJcbiAgICBpZiAoIWVudHJ5IHx8ICFlbnRyeS5jcm9zc1JlZmVyZW5jZXMpIHJldHVybiBbXTtcclxuXHJcbiAgICByZXR1cm4gZW50cnkuY3Jvc3NSZWZlcmVuY2VzXHJcbiAgICAgIC5tYXAoY3Jvc3NSZWYgPT4gKHtcclxuICAgICAgICAuLi5jcm9zc1JlZixcclxuICAgICAgICB0YXJnZXRFbnRyeTogdGhpcy5lbnRyaWVzLmdldChjcm9zc1JlZi50YXJnZXQpXHJcbiAgICAgIH0pKVxyXG4gICAgICAuZmlsdGVyKGNyb3NzUmVmID0+IGNyb3NzUmVmLnRhcmdldEVudHJ5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBlbmN5Y2xvcGVkaWEgc3RhdGlzdGljc1xyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFN0YXRpc3RpY3MgYWJvdXQgdGhlIGVuY3ljbG9wZWRpYVxyXG4gICAqL1xyXG4gIGdldFN0YXRpc3RpY3MoKSB7XHJcbiAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgdG90YWxFbnRyaWVzOiB0aGlzLmVudHJpZXMuc2l6ZSxcclxuICAgICAgY2F0ZWdvcmllczogdGhpcy5jYXRlZ29yaWVzLnNpemUsXHJcbiAgICAgIHNlYXJjaEluZGV4U2l6ZTogdGhpcy5zZWFyY2hJbmRleC5zaXplXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAoY29uc3QgW2NhdGVnb3J5TmFtZSwgY2F0ZWdvcnldIG9mIHRoaXMuY2F0ZWdvcmllcykge1xyXG4gICAgICBzdGF0c1tjYXRlZ29yeU5hbWVdID0gY2F0ZWdvcnkuZW50cmllcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0YXRzO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGZvciB1c2UgaW4gb3RoZXIgbW9kdWxlc1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVuY3ljbG9wZWRpYVN5c3RlbTtcclxufVxyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB3aW5kb3cuRW5jeWNsb3BlZGlhU3lzdGVtID0gRW5jeWNsb3BlZGlhU3lzdGVtO1xyXG5cclxuLy8gRVMgTW9kdWxlIGV4cG9ydHNcclxuZXhwb3J0IHsgRW5jeWNsb3BlZGlhU3lzdGVtIH07ICJdLCJuYW1lcyI6WyJFbmN5Y2xvcGVkaWFTeXN0ZW0iLCJpbml0aWFsaXplIiwiZ2FtZURhdGEiLCJpbml0aWFsaXplZCIsImxvYWRTa2lsbHNEYXRhIiwic2tpbGxzIiwibG9hZEl0ZW1zRGF0YSIsIml0ZW1zIiwibG9hZFNwZWNpZXNEYXRhIiwic3BlY2llcyIsImxvYWRUcmFpdHNEYXRhIiwidHJhaXRzIiwibG9hZExvY2F0aW9uc0RhdGEiLCJsb2NhdGlvbnMiLCJsb2FkQWN0aW9uc0RhdGEiLCJhY3Rpb25zIiwiYnVpbGRDcm9zc1JlZmVyZW5jZXMiLCJidWlsZFNlYXJjaEluZGV4IiwiY29uc29sZSIsImxvZyIsImVudHJpZXMiLCJzaXplIiwiZXJyb3IiLCJza2lsbHNEYXRhIiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwic2V0IiwibmFtZSIsImRlc2NyaXB0aW9uIiwiaWNvbiIsImNhdGVnb3J5TmFtZSIsImNhdGVnb3J5U2tpbGxzIiwiT2JqZWN0Iiwic2tpbGxOYW1lIiwic2tpbGxEYXRhIiwiZW50cnkiLCJpZCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsInR5cGUiLCJzdWJjYXRlZ29yeSIsImRhdGEiLCJ0YWdzIiwiY3Jvc3NSZWZlcmVuY2VzIiwicmVxdWlyZXMiLCJyZXF1aXJlbWVudHMiLCJwdXNoIiwidGFyZ2V0Iiwic2tpbGwiLCJsZXZlbCIsInN1Yl9za2lsbHMiLCJzdWJTa2lsbE5hbWUiLCJzdWJTa2lsbERhdGEiLCJnZXQiLCJpdGVtc0RhdGEiLCJpdGVtSWQiLCJpdGVtRGF0YSIsImRpc3BsYXlOYW1lIiwiZXhhbWluZVRleHQiLCJzdGFja2FibGUiLCJ1bmRlZmluZWQiLCJlcXVpcG1lbnRUeXBlIiwic3BlY2llc0RhdGEiLCJjYXRlZ29yeVNwZWNpZXMiLCJzcGVjaWVzSWQiLCJwcm9mZXNzaW9ucyIsInByb2Zlc3Npb24iLCJ0cmFpdHNEYXRhIiwidHJhaXRJZCIsInRyYWl0RGF0YSIsImxvY2F0aW9uc0RhdGEiLCJsb2NhdGlvbklkIiwibG9jYXRpb25EYXRhIiwiYWN0aW9uc0RhdGEiLCJhY3Rpb25JZCIsImFjdGlvbkRhdGEiLCJza2lsbFJlcXVpcmVkIiwiaXRlbXNSZXF1aXJlZCIsImtleXMiLCJlbnRyeUlkIiwiY3Jvc3NSZWYiLCJ0YXJnZXRFbnRyeSIsImFkZFRvU2VhcmNoSW5kZXgiLCJ0YWciLCJ0ZXJtIiwid29yZHMiLCJzcGxpdCIsIndvcmQiLCJsZW5ndGgiLCJzZWFyY2hJbmRleCIsImhhcyIsIlNldCIsImFkZCIsInNlYXJjaCIsInF1ZXJ5IiwicXVlcnlMb3dlciIsInF1ZXJ5V29yZHMiLCJyZXN1bHRzIiwiTWFwIiwibWF0Y2hlcyIsInNjb3JlIiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsImdldEVudHJ5IiwiZ2V0Q2F0ZWdvcmllcyIsInZhbHVlcyIsImdldEVudHJpZXNCeUNhdGVnb3J5IiwiZ2V0Q3Jvc3NSZWZlcmVuY2VzIiwiZ2V0U3RhdGlzdGljcyIsInN0YXRzIiwidG90YWxFbnRyaWVzIiwic2VhcmNoSW5kZXhTaXplIiwiY29uc3RydWN0b3IiLCJtb2R1bGUiLCJleHBvcnRzIiwid2luZG93Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/game-engine/systems/EncyclopediaSystem.js\n"));

/***/ })

}]);