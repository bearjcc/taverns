"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_game-engine_core_ModManager_js",{

/***/ "(app-pages-browser)/./src/lib/game-engine/core/ModManager.js":
/*!************************************************!*\
  !*** ./src/lib/game-engine/core/ModManager.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModManager: () => (/* binding */ ModManager)\n/* harmony export */ });\n/**\r\n * Mod Manager\r\n * \r\n * Handles loading and management of game mods.\r\n * Supports mod discovery, loading, and dependency resolution.\r\n */ class ModManager {\n    /**\r\n     * Initialize the mod manager\r\n     */ async initialize() {\n        console.log('Initializing Mod Manager');\n        // Discover available mods\n        await this.discoverMods();\n        // Load base game mod by default\n        await this.loadMod('base-game');\n        console.log('Mod Manager initialized');\n    }\n    /**\r\n     * Discover available mods in the mods directory\r\n     */ async discoverMods() {\n        try {\n            // For now, we'll hardcode the base game mod\n            // In the future, this could scan the mods directory\n            const baseGameManifest = await this.loadModManifest('/mods/base-game/manifest.json');\n            this.modManifests.set('base-game', baseGameManifest);\n            console.log(\"Discovered \".concat(this.modManifests.size, \" mod(s)\"));\n        } catch (error) {\n            console.error('Error discovering mods:', error);\n        }\n    }\n    /**\r\n     * Load a mod by ID\r\n     * @param {string} modId - The mod ID to load\r\n     * @returns {Object} The loaded mod data\r\n     */ async loadMod(modId) {\n        try {\n            console.log(\"Loading mod: \".concat(modId));\n            const manifest = this.modManifests.get(modId);\n            if (!manifest) {\n                throw new Error(\"Mod manifest not found: \".concat(modId));\n            }\n            // Check dependencies\n            await this.checkDependencies(manifest);\n            // Load mod data\n            const modData = await this.loadModData(manifest);\n            // Load mod assets\n            await this.loadModAssets(manifest);\n            // Load localization\n            await this.loadModLocalization(manifest);\n            // Store loaded mod\n            this.loadedMods.set(modId, {\n                manifest,\n                data: modData,\n                assets: {},\n                localization: {}\n            });\n            this.activeMods.add(modId);\n            this.modLoadOrder.push(modId);\n            // Emit mod loaded event\n            this.eventSystem.emit('mod:loaded', {\n                modId,\n                manifest,\n                data: modData\n            });\n            console.log(\"Mod loaded successfully: \".concat(modId));\n            return modData;\n        } catch (error) {\n            console.error(\"Failed to load mod \".concat(modId, \":\"), error);\n            throw error;\n        }\n    }\n    /**\r\n     * Load mod manifest from file\r\n     * @param {string} manifestPath - Path to the manifest file\r\n     * @returns {Object} The manifest data\r\n     */ async loadModManifest(manifestPath) {\n        try {\n            const response = await fetch(manifestPath);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Failed to load mod manifest \".concat(manifestPath, \":\"), error);\n            throw error;\n        }\n    }\n    /**\r\n     * Check mod dependencies\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async checkDependencies(manifest) {\n        const dependencies = manifest.dependencies || [];\n        for (const dependency of dependencies){\n            if (!this.loadedMods.has(dependency)) {\n                throw new Error(\"Missing dependency: \".concat(dependency));\n            }\n        }\n    }\n    /**\r\n     * Load mod data files\r\n     * @param {Object} manifest - The mod manifest\r\n     * @returns {Object} The loaded data\r\n     */ async loadModData(manifest) {\n        const data = {};\n        const dataFiles = manifest.data || {};\n        for (const [key, path] of Object.entries(dataFiles)){\n            try {\n                if (path.endsWith('/')) {\n                    // Directory - load all JSON files in directory\n                    data[key] = await this.loadDataDirectory(path);\n                } else {\n                    // Single file\n                    const response = await fetch(path);\n                    if (!response.ok) {\n                        console.warn(\"Failed to load data file: \".concat(path));\n                        continue;\n                    }\n                    data[key] = await response.json();\n                }\n            } catch (error) {\n                console.warn(\"Failed to load data file \".concat(path, \":\"), error);\n            }\n        }\n        return data;\n    }\n    /**\r\n     * Load all JSON files in a directory\r\n     * @param {string} directoryPath - Path to the directory\r\n     * @returns {Object} Object with filename keys and data values\r\n     */ async loadDataDirectory(directoryPath) {\n        // For now, we'll return an empty object\n        // In a real implementation, this would scan the directory\n        return {};\n    }\n    /**\r\n     * Load mod assets\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async loadModAssets(manifest) {\n        const assets = manifest.assets || {};\n        // For now, we'll just log the asset paths\n        // In a real implementation, this would preload assets\n        console.log('Mod assets:', assets);\n    }\n    /**\r\n     * Load mod localization\r\n     * @param {Object} manifest - The mod manifest\r\n     */ async loadModLocalization(manifest) {\n        const localization = manifest.localization || {};\n        const defaultLang = localization.default || 'en';\n        const langPath = localization.path || 'localization/';\n        try {\n            const response = await fetch(\"\".concat(langPath).concat(defaultLang, \".json\"));\n            if (response.ok) {\n                const langData = await response.json();\n                console.log('Loaded localization:', langData);\n            }\n        } catch (error) {\n            console.warn('Failed to load localization:', error);\n        }\n    }\n    /**\r\n     * Get loaded mod data\r\n     * @param {string} modId - The mod ID\r\n     * @returns {Object} The mod data\r\n     */ getModData(modId) {\n        const mod = this.loadedMods.get(modId);\n        return mod ? mod.data : null;\n    }\n    /**\r\n     * Get all loaded mod data merged together\r\n     * @returns {Object} Merged data from all loaded mods\r\n     */ getAllModData() {\n        const mergedData = {};\n        for (const [modId, mod] of this.loadedMods){\n            for (const [key, value] of Object.entries(mod.data)){\n                if (!mergedData[key]) {\n                    mergedData[key] = {};\n                }\n                // Merge data (mods loaded later override earlier ones)\n                if (typeof value === 'object' && value !== null) {\n                    Object.assign(mergedData[key], value);\n                } else {\n                    mergedData[key] = value;\n                }\n            }\n        }\n        return mergedData;\n    }\n    /**\r\n     * Get active mods\r\n     * @returns {Set} Set of active mod IDs\r\n     */ getActiveMods() {\n        return this.activeMods;\n    }\n    /**\r\n     * Get mod load order\r\n     * @returns {Array} Array of mod IDs in load order\r\n     */ getModLoadOrder() {\n        return this.modLoadOrder;\n    }\n    /**\r\n     * Unload a mod\r\n     * @param {string} modId - The mod ID to unload\r\n     */ unloadMod(modId) {\n        if (this.loadedMods.has(modId)) {\n            this.loadedMods.delete(modId);\n            this.activeMods.delete(modId);\n            const index = this.modLoadOrder.indexOf(modId);\n            if (index > -1) {\n                this.modLoadOrder.splice(index, 1);\n            }\n            this.eventSystem.emit('mod:unloaded', {\n                modId\n            });\n            console.log(\"Mod unloaded: \".concat(modId));\n        }\n    }\n    /**\r\n     * Reload a mod\r\n     * @param {string} modId - The mod ID to reload\r\n     */ async reloadMod(modId) {\n        this.unloadMod(modId);\n        await this.loadMod(modId);\n    }\n    constructor(eventSystem, assetLoader){\n        this.eventSystem = eventSystem;\n        this.assetLoader = assetLoader;\n        this.loadedMods = new Map();\n        this.modManifests = new Map();\n        this.activeMods = new Set();\n        this.modLoadOrder = [];\n    }\n}\nif (true) window.ModManager = ModManager;\n// ES Module exports\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZS1lbmdpbmUvY29yZS9Nb2RNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVELE1BQU1BO0lBVUY7O0tBRUMsR0FDRCxNQUFNQyxhQUFhO1FBQ2ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDBCQUEwQjtRQUMxQixNQUFNLElBQUksQ0FBQ0MsWUFBWTtRQUV2QixnQ0FBZ0M7UUFDaEMsTUFBTSxJQUFJLENBQUNDLE9BQU8sQ0FBQztRQUVuQkgsUUFBUUMsR0FBRyxDQUFDO0lBQ2hCO0lBRUE7O0tBRUMsR0FDRCxNQUFNQyxlQUFlO1FBQ2pCLElBQUk7WUFDQSw0Q0FBNEM7WUFDNUMsb0RBQW9EO1lBQ3BELE1BQU1FLG1CQUFtQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDO1lBQ3BELElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsYUFBYUg7WUFFbkNKLFFBQVFDLEdBQUcsQ0FBQyxjQUFxQyxPQUF2QixJQUFJLENBQUNLLFlBQVksQ0FBQ0UsSUFBSSxFQUFDO1FBQ3JELEVBQUUsT0FBT0MsT0FBTztZQUNaVCxRQUFRUyxLQUFLLENBQUMsMkJBQTJCQTtRQUM3QztJQUNKO0lBRUE7Ozs7S0FJQyxHQUNELE1BQU1OLFFBQVFPLEtBQUssRUFBRTtRQUNqQixJQUFJO1lBQ0FWLFFBQVFDLEdBQUcsQ0FBQyxnQkFBc0IsT0FBTlM7WUFFNUIsTUFBTUMsV0FBVyxJQUFJLENBQUNMLFlBQVksQ0FBQ00sR0FBRyxDQUFDRjtZQUN2QyxJQUFJLENBQUNDLFVBQVU7Z0JBQ1gsTUFBTSxJQUFJRSxNQUFNLDJCQUFpQyxPQUFOSDtZQUMvQztZQUVBLHFCQUFxQjtZQUNyQixNQUFNLElBQUksQ0FBQ0ksaUJBQWlCLENBQUNIO1lBRTdCLGdCQUFnQjtZQUNoQixNQUFNSSxVQUFVLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUNMO1lBRXZDLGtCQUFrQjtZQUNsQixNQUFNLElBQUks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Q3RCLElBQUksQ0FBQzNDLFlBQVksR0FBRyxFQUFFO0lBQzFCO0FBOFFKO0FBRUEsSUFBSSxJQUE2QixFQUFFNEMsT0FBT3ZFLFVBQVUsR0FBR0E7QUFFdkQsb0JBQW9CO0FBQ0UiLCJzb3VyY2VzIjpbIkM6XFxHaXRIdWJcXFNlbGZcXHRhdmVybnNcXHNyY1xcbGliXFxnYW1lLWVuZ2luZVxcY29yZVxcTW9kTWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTW9kIE1hbmFnZXJcclxuICogXHJcbiAqIEhhbmRsZXMgbG9hZGluZyBhbmQgbWFuYWdlbWVudCBvZiBnYW1lIG1vZHMuXHJcbiAqIFN1cHBvcnRzIG1vZCBkaXNjb3ZlcnksIGxvYWRpbmcsIGFuZCBkZXBlbmRlbmN5IHJlc29sdXRpb24uXHJcbiAqL1xyXG5cclxuY2xhc3MgTW9kTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFN5c3RlbSwgYXNzZXRMb2FkZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50U3lzdGVtID0gZXZlbnRTeXN0ZW07XHJcbiAgICAgICAgdGhpcy5hc3NldExvYWRlciA9IGFzc2V0TG9hZGVyO1xyXG4gICAgICAgIHRoaXMubG9hZGVkTW9kcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm1vZE1hbmlmZXN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZU1vZHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb2RMb2FkT3JkZXIgPSBbXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBtb2QgbWFuYWdlclxyXG4gICAgICovXHJcbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgTW9kIE1hbmFnZXInKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEaXNjb3ZlciBhdmFpbGFibGUgbW9kc1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZGlzY292ZXJNb2RzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9hZCBiYXNlIGdhbWUgbW9kIGJ5IGRlZmF1bHRcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2QoJ2Jhc2UtZ2FtZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb2QgTWFuYWdlciBpbml0aWFsaXplZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIERpc2NvdmVyIGF2YWlsYWJsZSBtb2RzIGluIHRoZSBtb2RzIGRpcmVjdG9yeVxyXG4gICAgICovXHJcbiAgICBhc3luYyBkaXNjb3Zlck1vZHMoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgaGFyZGNvZGUgdGhlIGJhc2UgZ2FtZSBtb2RcclxuICAgICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBzY2FuIHRoZSBtb2RzIGRpcmVjdG9yeVxyXG4gICAgICAgICAgICBjb25zdCBiYXNlR2FtZU1hbmlmZXN0ID0gYXdhaXQgdGhpcy5sb2FkTW9kTWFuaWZlc3QoJy9tb2RzL2Jhc2UtZ2FtZS9tYW5pZmVzdC5qc29uJyk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kTWFuaWZlc3RzLnNldCgnYmFzZS1nYW1lJywgYmFzZUdhbWVNYW5pZmVzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRGlzY292ZXJlZCAke3RoaXMubW9kTWFuaWZlc3RzLnNpemV9IG1vZChzKWApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRpc2NvdmVyaW5nIG1vZHM6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGEgbW9kIGJ5IElEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kSWQgLSBUaGUgbW9kIElEIHRvIGxvYWRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2FkZWQgbW9kIGRhdGFcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZE1vZChtb2RJZCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkaW5nIG1vZDogJHttb2RJZH1gKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gdGhpcy5tb2RNYW5pZmVzdHMuZ2V0KG1vZElkKTtcclxuICAgICAgICAgICAgaWYgKCFtYW5pZmVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2QgbWFuaWZlc3Qgbm90IGZvdW5kOiAke21vZElkfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0RlcGVuZGVuY2llcyhtYW5pZmVzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2FkIG1vZCBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IG1vZERhdGEgPSBhd2FpdCB0aGlzLmxvYWRNb2REYXRhKG1hbmlmZXN0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIExvYWQgbW9kIGFzc2V0c1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2RBc3NldHMobWFuaWZlc3QpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTG9hZCBsb2NhbGl6YXRpb25cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTW9kTG9jYWxpemF0aW9uKG1hbmlmZXN0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIGxvYWRlZCBtb2RcclxuICAgICAgICAgICAgdGhpcy5sb2FkZWRNb2RzLnNldChtb2RJZCwge1xyXG4gICAgICAgICAgICAgICAgbWFuaWZlc3QsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBtb2REYXRhLFxyXG4gICAgICAgICAgICAgICAgYXNzZXRzOiB7fSxcclxuICAgICAgICAgICAgICAgIGxvY2FsaXphdGlvbjoge31cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vZHMuYWRkKG1vZElkKTtcclxuICAgICAgICAgICAgdGhpcy5tb2RMb2FkT3JkZXIucHVzaChtb2RJZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFbWl0IG1vZCBsb2FkZWQgZXZlbnRcclxuICAgICAgICAgICAgdGhpcy5ldmVudFN5c3RlbS5lbWl0KCdtb2Q6bG9hZGVkJywge1xyXG4gICAgICAgICAgICAgICAgbW9kSWQsXHJcbiAgICAgICAgICAgICAgICBtYW5pZmVzdCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IG1vZERhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTW9kIGxvYWRlZCBzdWNjZXNzZnVsbHk6ICR7bW9kSWR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2REYXRhO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBtb2QgJHttb2RJZH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBtb2QgbWFuaWZlc3QgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RQYXRoIC0gUGF0aCB0byB0aGUgbWFuaWZlc3QgZmlsZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG1hbmlmZXN0IGRhdGFcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZE1vZE1hbmlmZXN0KG1hbmlmZXN0UGF0aCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobWFuaWZlc3RQYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kIG1hbmlmZXN0ICR7bWFuaWZlc3RQYXRofTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBtb2QgZGVwZW5kZW5jaWVzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFuaWZlc3QgLSBUaGUgbW9kIG1hbmlmZXN0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNoZWNrRGVwZW5kZW5jaWVzKG1hbmlmZXN0KSB7XHJcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbWFuaWZlc3QuZGVwZW5kZW5jaWVzIHx8IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZE1vZHMuaGFzKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZGVwZW5kZW5jeTogJHtkZXBlbmRlbmN5fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgbW9kIGRhdGEgZmlsZXNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5pZmVzdCAtIFRoZSBtb2QgbWFuaWZlc3RcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2FkZWQgZGF0YVxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkTW9kRGF0YShtYW5pZmVzdCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcclxuICAgICAgICBjb25zdCBkYXRhRmlsZXMgPSBtYW5pZmVzdC5kYXRhIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcGF0aF0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YUZpbGVzKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpcmVjdG9yeSAtIGxvYWQgYWxsIEpTT04gZmlsZXMgaW4gZGlyZWN0b3J5XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gYXdhaXQgdGhpcy5sb2FkRGF0YURpcmVjdG9yeShwYXRoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCBkYXRhIGZpbGU6ICR7cGF0aH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxvYWQgZGF0YSBmaWxlICR7cGF0aH06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYWxsIEpTT04gZmlsZXMgaW4gYSBkaXJlY3RvcnlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3RvcnlQYXRoIC0gUGF0aCB0byB0aGUgZGlyZWN0b3J5XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBmaWxlbmFtZSBrZXlzIGFuZCBkYXRhIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkRGF0YURpcmVjdG9yeShkaXJlY3RvcnlQYXRoKSB7XHJcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxyXG4gICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBzY2FuIHRoZSBkaXJlY3RvcnlcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBtb2QgYXNzZXRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFuaWZlc3QgLSBUaGUgbW9kIG1hbmlmZXN0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWRNb2RBc3NldHMobWFuaWZlc3QpIHtcclxuICAgICAgICBjb25zdCBhc3NldHMgPSBtYW5pZmVzdC5hc3NldHMgfHwge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBsb2cgdGhlIGFzc2V0IHBhdGhzXHJcbiAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHByZWxvYWQgYXNzZXRzXHJcbiAgICAgICAgY29uc29sZS5sb2coJ01vZCBhc3NldHM6JywgYXNzZXRzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIG1vZCBsb2NhbGl6YXRpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYW5pZmVzdCAtIFRoZSBtb2QgbWFuaWZlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZE1vZExvY2FsaXphdGlvbihtYW5pZmVzdCkge1xyXG4gICAgICAgIGNvbnN0IGxvY2FsaXphdGlvbiA9IG1hbmlmZXN0LmxvY2FsaXphdGlvbiB8fCB7fTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0TGFuZyA9IGxvY2FsaXphdGlvbi5kZWZhdWx0IHx8ICdlbic7XHJcbiAgICAgICAgY29uc3QgbGFuZ1BhdGggPSBsb2NhbGl6YXRpb24ucGF0aCB8fCAnbG9jYWxpemF0aW9uLyc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtsYW5nUGF0aH0ke2RlZmF1bHRMYW5nfS5qc29uYCk7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFuZ0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIGxvY2FsaXphdGlvbjonLCBsYW5nRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIGxvY2FsaXphdGlvbjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEdldCBsb2FkZWQgbW9kIGRhdGFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RJZCAtIFRoZSBtb2QgSURcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2QgZGF0YVxyXG4gICAgICovXHJcbiAgICBnZXRNb2REYXRhKG1vZElkKSB7XHJcbiAgICAgICAgY29uc3QgbW9kID0gdGhpcy5sb2FkZWRNb2RzLmdldChtb2RJZCk7XHJcbiAgICAgICAgcmV0dXJuIG1vZCA/IG1vZC5kYXRhIDogbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIGxvYWRlZCBtb2QgZGF0YSBtZXJnZWQgdG9nZXRoZXJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE1lcmdlZCBkYXRhIGZyb20gYWxsIGxvYWRlZCBtb2RzXHJcbiAgICAgKi9cclxuICAgIGdldEFsbE1vZERhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkRGF0YSA9IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgW21vZElkLCBtb2RdIG9mIHRoaXMubG9hZGVkTW9kcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtb2QuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbWVyZ2VkRGF0YVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkRGF0YVtrZXldID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIGRhdGEgKG1vZHMgbG9hZGVkIGxhdGVyIG92ZXJyaWRlIGVhcmxpZXIgb25lcylcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZXJnZWREYXRhW2tleV0sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkRGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG1lcmdlZERhdGE7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFjdGl2ZSBtb2RzXHJcbiAgICAgKiBAcmV0dXJucyB7U2V0fSBTZXQgb2YgYWN0aXZlIG1vZCBJRHNcclxuICAgICAqL1xyXG4gICAgZ2V0QWN0aXZlTW9kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVNb2RzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEdldCBtb2QgbG9hZCBvcmRlclxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBtb2QgSURzIGluIGxvYWQgb3JkZXJcclxuICAgICAqL1xyXG4gICAgZ2V0TW9kTG9hZE9yZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZExvYWRPcmRlcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxvYWQgYSBtb2RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RJZCAtIFRoZSBtb2QgSUQgdG8gdW5sb2FkXHJcbiAgICAgKi9cclxuICAgIHVubG9hZE1vZChtb2RJZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZE1vZHMuaGFzKG1vZElkKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlZE1vZHMuZGVsZXRlKG1vZElkKTtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb2RzLmRlbGV0ZShtb2RJZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubW9kTG9hZE9yZGVyLmluZGV4T2YobW9kSWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RMb2FkT3JkZXIuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5ldmVudFN5c3RlbS5lbWl0KCdtb2Q6dW5sb2FkZWQnLCB7IG1vZElkIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTW9kIHVubG9hZGVkOiAke21vZElkfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxvYWQgYSBtb2RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RJZCAtIFRoZSBtb2QgSUQgdG8gcmVsb2FkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlbG9hZE1vZChtb2RJZCkge1xyXG4gICAgICAgIHRoaXMudW5sb2FkTW9kKG1vZElkKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2QobW9kSWQpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHdpbmRvdy5Nb2RNYW5hZ2VyID0gTW9kTWFuYWdlcjtcclxuXHJcbi8vIEVTIE1vZHVsZSBleHBvcnRzXHJcbmV4cG9ydCB7IE1vZE1hbmFnZXIgfTsgIl0sIm5hbWVzIjpbIk1vZE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY29uc29sZSIsImxvZyIsImRpc2NvdmVyTW9kcyIsImxvYWRNb2QiLCJiYXNlR2FtZU1hbmlmZXN0IiwibG9hZE1vZE1hbmlmZXN0IiwibW9kTWFuaWZlc3RzIiwic2V0Iiwic2l6ZSIsImVycm9yIiwibW9kSWQiLCJtYW5pZmVzdCIsImdldCIsIkVycm9yIiwiY2hlY2tEZXBlbmRlbmNpZXMiLCJtb2REYXRhIiwibG9hZE1vZERhdGEiLCJsb2FkTW9kQXNzZXRzIiwibG9hZE1vZExvY2FsaXphdGlvbiIsImxvYWRlZE1vZHMiLCJkYXRhIiwiYXNzZXRzIiwibG9jYWxpemF0aW9uIiwiYWN0aXZlTW9kcyIsImFkZCIsIm1vZExvYWRPcmRlciIsInB1c2giLCJldmVudFN5c3RlbSIsImVtaXQiLCJtYW5pZmVzdFBhdGgiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeSIsImhhcyIsImRhdGFGaWxlcyIsImtleSIsInBhdGgiLCJPYmplY3QiLCJlbnRyaWVzIiwiZW5kc1dpdGgiLCJsb2FkRGF0YURpcmVjdG9yeSIsIndhcm4iLCJkaXJlY3RvcnlQYXRoIiwiZGVmYXVsdExhbmciLCJkZWZhdWx0IiwibGFuZ1BhdGgiLCJsYW5nRGF0YSIsImdldE1vZERhdGEiLCJtb2QiLCJnZXRBbGxNb2REYXRhIiwibWVyZ2VkRGF0YSIsInZhbHVlIiwiYXNzaWduIiwiZ2V0QWN0aXZlTW9kcyIsImdldE1vZExvYWRPcmRlciIsInVubG9hZE1vZCIsImRlbGV0ZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInJlbG9hZE1vZCIsImNvbnN0cnVjdG9yIiwiYXNzZXRMb2FkZXIiLCJNYXAiLCJTZXQiLCJ3aW5kb3ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/game-engine/core/ModManager.js\n"));

/***/ })

});